/* REXX */
/*********************************************************************/
/*                                                                   */
/* This exec reads in a series of records defining the configuration */
/* requirements for an OSA and writes out a formatted OAT (OSA       */
/* Address Table) ready for loading with OSA/SF. The OAT is written  */
/* in the extended (old) format, summary format is not supported as  */
/* we don't have the PTF on yet - ho hum !                           */
/*                                                                   */
/* Note: This exec only supports OSA-1 with SNA and TCP/IP. Other    */
/*       protocols (ATM etc) are not supported. This exec also       */
/*       does not support multiple IP home addresses.                */
/*                                                                   */
/*  Input:  DDName Input  = OSA configuration deck                   */
/*                                                                   */
/*  Output: DDName Output = Formatted OAT ready for loading into the */
/*                          OSA                                      */
/*                                                                   */
/*  If an error is detected, a message describing the condition is   */
/*  displayed and processing is terminated.                          */
/*                                                                   */
/*********************************************************************/

signal on novalue

Trace 'o'

Call Initialise                       /* Initialise globals etc */

Call LoadInput                        /* Read and parse input   */

Call ValidateInput                    /* Check input validity   */

Call GenerateOat                      /* Generate the OAT       */

Call UnloadOat                        /* Write out OAT          */

exit

/*********************************************************************/
/* Initialise: Set up any global variables                           */
/*********************************************************************/
Initialise:
  SeenOsa = 0
  SeenPart = 0
  do p = 1 to 15
    parts.p = ''
  end
  parts.0 = 0

  MaxPort = 4    /* Maximum port - not counting special FF port */

  DecString = '0123456789'
  HexString = '0123456789ABCDEF'
  BoxStart = '/'||copies('*',69)||'/'

  Oats.0 = 0

   /* Define some constant values */

  OatType = 1
  OatPort = 2
  OatDevNum = 3
  OatUnitAddr = 4
  OatPart = 5
  OatDef = 6
  OatIP = 7
  OatID = 8

  OatSna = 1
  OatTcp = 2

  OatTable.0 = 0

  Return

/*********************************************************************/
/* GenerateOat: Generate the OAT table                               */
/*********************************************************************/
GenerateOat:
  if Oats.0 = 0 then
    FatalError('Nothing to generate - no port definitions','')

    /* Calcalate how many entries are required */

  Entries = 0
  do i = 1 to Oats.0
    if Oats.i.OatType = OatSna then
      Entries = Entries + Oats.i.OatParts.0
    else if Oats.i.OatType = OatTcp then
      Entries = Entries + (Oats.i.OatParts.0 * 2)
  end

  Call BoxCentre('OAT generated by GENOAT on' Date('E') 'by' Userid())
  Call BoxCentre('Start of OSA Address Table')

  Str = 'All entries below that are preceeded by ''s-'' indicate that'
  str = str 'the field is settable during Put_OAT processing'
  Call BoxOut(str)


     /*******************************/
     /* Generate the Base Oat entry */
     /*******************************/

  Call BoxOut('Start of Base OAT entry')

  str = 'oathdr.1 = IOA_OAT_HDR'
  Call OatOut str,'Eyecatcher-Do not change'

  str = 'oathdr.2 =' OsaChannel
  call OatOut str,'s-Chpid'

  str = 'oathdr.3 =' Entries
  call OatOut str,'s-number of entries'

     /**********************************************/
     /* Loop through the Oat table generating OAT  */
     /* entries as required                        */
     /**********************************************/

  OatCount = 0

  do o = 1 to Oats.0                     /* for each entry */
    do p = 1 to Oats.o.OatParts.0        /* for each LPAR  */
      call OutputOat o,p,1               /* output an OAT  */
      if Oats.o.OatType = OatTcp then    /* For TCP ports  */
        call OutputOat o,p,2             /* Gen 2nd entry  */
    end
  end

    /* Sanity Check */

  if OatCount <> Entries then
    do
      Str = 'Expected:' Entries 'Actual:' OatCount
      FatalError('Logic error - OAT count mismatch',Str)
    end

  Return

/*********************************************************************/
/* OutputOat: Generates a single OAT entry                           */
/*********************************************************************/
OutputOat:
  parse arg on,pn,gn

  OatCount = OatCount + 1

  Call BoxOut('Start of OAT entry' OatCount)

  OatStr = 'oat.'||OatCount||'.'

  Str = OatStr||'1 = IOA_OATENTRY'
  call OatOut Str,'Eyecatcher- do not delete'

  Str = OatStr||'2 = All data is valid'
  call OatOut Str,'Valid data indicator'

  parn = Oats.on.OatParts.pn
  Str = OatStr||'3 =' Parts.parn
  Call OatOut Str,'Partition name'

  Str = OatStr||'4 =' parn
  call OatOut Str,'s-Partition number'

  OatUnit = Oats.on.OatUnitAddr
  if gn = 2 then
    OatUnit = right(d2x(x2d(OatUnit)+1) ,2,'0')

  Str = OatStr||'5 =' OatUnit
  call OatOut Str,'s-unit address'

  OatDev = Oats.on.OatDevNum
  if gn = 2 then
    OatDev = right(d2x(x2d(OatDev)+1) ,4,'0')

  Str = OatStr||'6 =' OatDev
  call OatOut Str,'device number'

  Str = OatStr||'7 =' OsaChannel
  call OatOut Str,'Chpid'

  Str = OatStr||'8 =' OsaCU
  call OatOut Str,'control unit number'

  Str = OatStr||'9 = configured'
  call OatOut Str,'channel state'

  Str = OatStr||'10 = yes'
  call OatOut Str,'device accessible'

  if Oats.on.OatType = OatSna then
    gs = '01'
  else
    gs = '02'

  Str = OatStr||'11 =' gs
  call OatOut Str,'s-group size'

  if Oats.on.OatType = OatSna then
    et = 'SNA'
  else
    et = 'passthru'

  Str = OatStr||'12 =' et
  call OatOut Str,'s-entry type'

  Str = OatStr||'13 = started'
  call OatOut Str,'entry descriptor'

     /* finally, generate the extended OAT entry */

  call BoxOut('Start of Extended OAT entry')

  if Oats.on.OatType = OatSna then
    do
      OatStr = 'sna.'||OatCount

      Str = OatStr||'.1 =' Oats.on.OatPort
      call OatOut Str,'s-Port number'

      if Oats.on.OatPort = 'FF' then
        do
          Str = OatStr||'.2 =' Oats.on.OatID
          call OatOut Str,'s-VTAM ID number'
        end
    end
  else
    do
      OatStr = 'passthru.'||OatCount

      Str = OatStr||'.1 =' Oats.on.OatPort
      call OatOut Str,'s-Port number'

      if Oats.On.OatDef = pn then
        Str = OatStr||'.2 = yes'
      else
        Str = OatStr||'.2 = no'
      Call OatOut Str,'s-Default LP (yes/no)'

      Str = OatStr||'.3 =' Oats.on.OatIP.pn
      Call OatOut Str,'s-home IP address'

    end

  Return
/*********************************************************************/
/* LoadInput: Reads the OSA definition data and parses it            */
/*********************************************************************/
LoadInput:

  'EXECIO * DISKR INPUT (FINIS STEM OSADEF.'

  do i = 1 to osadef.0
    if substr(osadef.i,1,1) <> '*' then
      do
        params = strip(substr(osadef.i,1,72),'B')

        Call Tokenise(params)

        if tokens.0 > 0 then
          do
            Select
              When tokens.1 = 'OSA' then
                Call ProcessOSA
              When tokens.1 = 'PART' then
                Call ProcessPart
              When tokens.1 = 'SNA' then
                Call ProcessSNA
              When tokens.1 = 'TCP' then
                Call ProcessTCP
              Otherwise
                FatalError('Unreconized Input',Tokens.1)
            end
          end
      end
  end

  Return

/*********************************************************************/
/* ValidateInput: Validate the cross statement consistancy           */
/*********************************************************************/
ValidateInput:

   /*********************************************************/
   /* Check that a port is not used twice for the same type */
   /* of definition (SNA or TCP)                            */
   /*********************************************************/

  if Oats.0 > 1 then
    do
      do o1 = 1 to Oats.0
        do o2 = 1 to Oats.0
          if o1 <> o2 then
            if Oats.o1.OatType = Oats.o2.OatType then
              if Oats.o1.OatPort = Oats.o2.OatPort then
                do
                  m = 'Port defined twice for same type (SNA/TCP)'
                  d = 'Port =' Oats.o1.OatPort
                  FatalError(m,d)
                end
        end
      end
    end

   /*********************************************************/
   /* Check that a device addr is not used more than once   */
   /*********************************************************/

  if Oats.0 > 1 then
    do
      do o1 = 1 to Oats.0
        do o2 = 1 to Oats.0
          if o1 <> o2 then
            do
              if Oats.o1.OatType = Oats.o2.OatType then
                do
                  if Oats.o1.OatDevNum = Oats.o2.OatDevNum then
                    do
                      m = 'device number defined more than once'
                      d = 'Device =' Oats.o1.OatDevNum
                      FatalError(m,d)
                    end
                end
              else
                do
                  if Oats.o1.OatType = OatTcp then
                    do
                      n1 = x2d(Oats.o2.OatDevNum)
                      n2 = x2d(Oats.o1.OatDevNum)
                      n3 = n2+1
                    end
                  else
                    do
                      n1 = x2d(Oats.o1.OatDevNum)
                      n2 = x2d(Oats.o2.OatDevNum)
                      n3 = n2+1
                    end
                  if (n1 = n2) | (n1 = n3) then
                    do
                      m = 'device number defined more than once'
                      d = 'Device =' Oats.o1.OatDevNum
                      FatalError(m,d)
                    end
                end
            end
        end
      end
    end

  Return

/*********************************************************************/
/* UnloadOat - Write out generated OAT to DD name 'OUTPUT'           */
/*********************************************************************/
UnloadOat:

  'EXECIO * DISKW OUTPUT (STEM OATTABLE.'

  Return

/*********************************************************************/
/* ProcessOSA - Process the OSA statement                            */
/*********************************************************************/
ProcessOSA:
  if SeenOSA = 1 then
    FatalError('More than one OSA statement provided','')
  else
    do
      SeenOSA = 1
      if tokens.0 = 3 then
        do
          if (Length(tokens.2) = 2) & ,
             (Verify(tokens.2,HexString) = 0) then
            do
              if (Length(tokens.3) = 4) & ,
                 (Verify(tokens.3,DecString) = 0) then
                do
                  OsaChannel = tokens.2
                  OsaCU = tokens.3
                end
              else
                FatalError('OSA CU number is invalid',tokens.3)
            end
          else
            FatalError('OSA channel number is invalid',tokens.2)
        end
      else
        FatalError('Incorrect number of OSA parameters','')
    end
  return

/*********************************************************************/
/* ProcessPart - Process the PART statement                          */
/*********************************************************************/
ProcessPart:

  if tokens.0 = 2 then
    do
      p = parts.0 + 1
      if p > 15 then
        FatalError('Too many PART statements','')
      else
        do
          if parts.p = '' then
            parts.p = tokens.2
          else
            FatalError('Duplicate PART definition',tokens.2)
        end
    end
  else if tokens.0 = 3 then
    do
      if verify(tokens.3,DecString) = 0 then
        do
          p = tokens.3
          if (p > 0) & (P < 16) then
            do
              if parts.p = '' then
                parts.p = tokens.2
              else
                FatalError('Duplicate PART number',tokens.2)
            end
          else
            FatalError('Partition number not 1 to 15',p)
        end
      else
        FatalError('Partition number invalid',tokens.3)

      do p1 = 1 to 15
        do p2 = 1 to 15
          if p1 <> p2 then
            if parts.p1 <> '' then
              if parts.p1 = parts.p2 then
                FatalError('Duplicate PART name',tokens.2)
        end
      end

      p = 0
      do p1 = 1 to 15
        if parts.p1 <> '' then
          p = p + 1
      end
      parts.0 = p
    end
  else
    FatalError('Incorrect number of PART params','')

  SeenPart = 1
  Return

/*********************************************************************/
/* ProcessSna: Process the SNA statement                             */
/*********************************************************************/
ProcessSna:
  if SeenOsa = 0 then
    FatalError('Missing or misplaced OSA Statement','')
  else if SeenPart = 0 then
    FatalError('Missing or misplaced PART statement','')
  else if tokens.0 > 3 then
    do
        /* Verify Port */

      SnaPort = tokens.2
      if verify(SnaPort,HexString) = 0 then
        do
          if (SnaPort <> 'FF') & (SnaPort > MaxPort) then
            FatalError('Port number is too high',UnTok())
        end
      else
        FatalError('Port number is invalid',UnTok())

        /* Verify device number and unit address */

      if length(tokens.3) = 4 then
        do
          SnaDevice = tokens.3
          if verify(SnaDevice,HexString) = 0 then
            SnaUnit = Substr(SnaDevice,3,2)
          else
            FatalError('Device number is invalid',UnTok())
        end
      else if (length(tokens.3) = 6) & ,
              (Substr(tokens.3,5,1) = '-') then
        do
          SnaDevice = Substr(tokens.3,1,4)
          SnaUnit = Substr(tokens.3,6,2)
          if verify(SnaDevice,HexString) > 0 then
            FatalError('Device number is invalid',UnTok())
          if verify(SnaUnit,HexString) > 0 then
            FatalError('Unit Address is invalid',UnTok())
        end
      else
        FatalError('Device number is invalid',UnTok())

        /* Verify partitions */

      SnaParts.0 = Words(Tokens.4)
      do p = 1 to SnaParts.0
        SnaPart = Word(Tokens.4,p)
        if verify(SnaPart,DecString) = 0 then
          do
            if (SnaPart < 1) | (SnaPart > parts.0) | ,
               (parts.SnaPart = '') then
              FatalError('Undefined partition selected',UnTok())
          end
        else
          do
            do p1 = 1 to parts.0
              if parts.p1 = SnaPart then
                SnaPart = p1
            end

            if verify(SnaPart,DecString) > 0 then
              FatalError('Undefined partition selected',UnTok())
          end
        SnaParts.p = SnaPart
      end

      SnaID = 0

      if SnaPort = 'FF' then
        do
          if SnaParts.0 > 1 then
            FatalError('Netview port cannot be shared',UnTok())
          if tokens.0 <> 5 then
            FatalError('VTAM ID is required for port FF',UnTok())
          if (length(tokens.5) <> 5) | ,
             (Verify(tokens.5,HexString) <> 0) then
            FatalError('VTAM ID is invalid',UnTok())
          if substr(Tokens.5,1,1) = '0' then
            FatalError('VTAM ID should not begin with a zero',UnTok())
            SnaID = tokens.5
        end
      else if tokens.0 > 4 then
        FatalError('Too many SNA parameters',UnTok())

         /* Add this definition to the Oat list */

      Oat = Oats.0 + 1
      Oats.Oat.OatType = OatSna
      Oats.Oat.OatPort = SnaPort
      Oats.Oat.OatDevNum = SnaDevice
      Oats.Oat.OatUnitAddr = SnaUnit
      Oats.Oat.OatParts.0 = SnaParts.0
      do p1 = 1 to SnaParts.0
        Oats.Oat.OatParts.p1 = SnaParts.p1
      end
      Oats.Oat.OatID = SnaID
      Oats.0 = Oat
    end
  else
    FatalError('Incorrect no. of SNA parameters',UnTok())
Return

/*********************************************************************/
/* ProcessTcp: Process the TCP statement                             */
/*********************************************************************/
ProcessTcp:
  if SeenOsa = 0 then
    FatalError('Missing or misplaced OSA Statement','')
  else if SeenPart = 0 then
    FatalError('Missing or misplaced PART statement','')
  else if (tokens.0 > 3) & (tokens.0 < 7) then
    do
        /* Verify Port */

      TcpPort = tokens.2
      if verify(TcpPort,HexString) = 0 then
        do
          if TcpPort > MaxPort then
            FatalError('Port number is too high',UnTok())
        end
      else
        FatalError('Port number is invalid',UnTok())

        /* Verify device number and unit address */

      if length(tokens.3) = 4 then
        do
          TcpDevice = tokens.3
          if verify(TcpDevice,HexString) = 0 then
            TcpUnit = Substr(TcpDevice,3,2)
          else
            FatalError('Device number is invalid',UnTok())
        end
      else if (length(tokens.3) = 6) & ,
              (Substr(tokens.3,5,1) = '-') then
        do
          TcpDevice = Substr(tokens.3,1,4)
          TcpUnit = Substr(tokens.3,6,2)
          if verify(TcpDevice,HexString) > 0 then
            FatalError('Device number is invalid',UnTok())
          if verify(TcpUnit,HexString) > 0 then
            FatalError('Unit Address is invalid',UnTok())
        end
      else
        FatalError('Device number is invalid',UnTok())

      if X2d(TcpDevice) // 2 = 1 then
        FatalError('Device number must be even for TCP/IP',UnTok())

        /* Verify partitions */

      TcpParts.0 = Words(Tokens.4)
      do p = 1 to TcpParts.0
        TcpPart = Word(Tokens.4,p)
        if verify(TcpPart,DecString) = 0 then
          do
            if (TcpPart < 1) | (TcpPart > parts.0) | ,
               (parts.TcpPart = '') then
              FatalError('Undefined partition selected',UnTok())
          end
        else
          do
            do p1 = 1 to parts.0
              if parts.p1 = TcpPart then
                TcpPart = p1
            end

            if verify(TcpPart,DecString) > 0 then
              FatalError('Undefined partition selected',UnTok())
          end
        TcpParts.p = TcpPart
      end

         /* Verify the IP addresses (if given) */

      if TcpParts.0 > 1 then
        if tokens.0 < 5 then
          FatalError('IP addresses missing for shared PORT',UnTok())

      if tokens.0 > 4 then
        do
          if words(tokens.5) <> TcpParts.0 then
            FatalError('IP count <> Partition count',UnTok())

          TcpIP.0 = words(tokens.5)
          do ipc = 1 to words(tokens.5)
            TcpIP.ipc = VerifyIP(word(tokens.5,ipc))
          end
        end
      else
        do
          TcpIP.0 = 1
          TcpIP.1 = '0.0.0.0'
        end

         /* Verify the default LP is valid */

      if TcpParts.0 > 1 then
        if tokens.0 < 6 then
          FatalError('Default LPAR missing for shared PORT',UnTok())
      if Tokens.0 = 6 then
        do
          if verify(tokens.6,DecString) = 0 then
            do
              TcpDef = Tokens.6
              if (TcpDef < 1) | (TcpDef > Parts.0) then
                FatalError('Invalid default LPAR number',UnTok())
              else if Parts.TcpDef = '' then
                FatalError('default LPAR not defined',UnTok())
            end
          else
            do
              TcpDef = 0
              do pn = 1 to parts.0
                if parts.pn = tokens.6 then
                  TcpDef = pn
              end
              if TcpDef = 0 then
                FatalError('default LPAR not defined',UnTok())
            end
        end
      else
        TcpDef = 0

         /* Add this definition to the Oat list */

      Oat = Oats.0 + 1
      Oats.Oat.OatType = OatTcp
      Oats.Oat.OatPort = TcpPort
      Oats.Oat.OatDevNum = TcpDevice
      Oats.Oat.OatUnitAddr = TcpUnit
      Oats.Oat.OatParts.0 = TcpParts.0
      do p1 = 1 to TcpParts.0
        Oats.Oat.OatParts.p1 = TcpParts.p1
      end
      Oats.Oat.OatIP.0 = TcpIP.0
      do p1 = 1 to TcpIP.0
        Oats.Oat.OatIP.p1 = TcpIP.p1
      end
      Oats.Oat.OatDef = TcpDef
      Oats.0 = Oat
    end
  else
    FatalError('Incorrect no. of TCP parameters',UnTok())
Return

/*********************************************************************/
/* VerifyIP: Verify a dotted IP address is validish                  */
/*********************************************************************/
VerifyIP:
  parse arg IP

  parse var IP ip.1 '.' ip.2 '.' ip.3 '.' ip.4

  ipt = 0
  do ipn = 1 to 4
    if ip.ipn = '' then
      FatalError('Invalid IP address',UnTok())
    if verify(ip.ipn,DecString) > 0 then
      FatalError('Invalid IP address',UnTok())
    if ip.ipn > 255 then
      FatalError('Invalid IP address',UnTok())
    ipt = ipt + ip.ipn
  end

  if ipt = 0 then
    FatalError('IP address 0.0.0.0 not allowed',UnTok())

  return IP

/*********************************************************************/
/* UnTok: Strings the tokens back together for diagnostic display    */
/*********************************************************************/
UnTok:
  String = ''
  do t = 1 to tokens.0
    if Pos(' ',tokens.t) = 0 then
      do
        if string = '' then
          string = tokens.t
        else
          string = string||','||tokens.t
      end
    else
      do
        parm = '('||translate(tokens.t,',',' ')||')'
        if string = '' then
          string = parm
        else
          string = string||','||parm
      end
  end
  return string

/*********************************************************************/
/* Tokenise: Converts a comma separated string into separate tokens  */
/*********************************************************************/
Tokenise:
  arg source
  line = source

  NumTok = 0
  do while (length(source) > 0)
    if substr(source,1,1) = '(' then
      do
        ClosParen = pos(')',source)
        if ClosParen > 0 then
          do
            token = Strip(substr(source,2,ClosParen-2),'B')
            source = Strip(substr(source,ClosParen+1,100),'B')
            token = Translate(token,' ',',')
            if length(source) > 0 then
              do
                if substr(source,1,1) = ',' then
                  source = strip(substr(source,2,100),'B')
                else
                  FatalError('syntax error (missing comma)',line)
              end
          end
        else
          FatalError('Unbalanced parenthesis',line)
      end
    else
      do
        sep = pos(',',source)
        if sep > 0 then
          do
            Token = Strip(substr(source,1,sep-1),'B')
            source = strip(substr(source,sep+1,100),'B')
          end
        else
          do
            Token = Strip(Source,'B')
            source = ''
          end
      end
    NumTok = NumTok + 1
    Tokens.NumTok = Token
  end

  Tokens.0 = NumTok
  Return

FatalError:
  parse arg Reason,Data
  say 'Fatal error:' Reason
  if Data <> '' then
    say '  Data:     ' Data
  exit

novalue:
  Say 'NoValue raised on line' Sigl 'Variable' condition('D')
  exit

BoxCentre:
  Parse arg data

  call out(BoxStart)

  string = ''
  do w = 1 to words(data)
    wrd = word(data,w)
    if length(string wrd) > 65 then
      do
        if length(string) < 65 then
          do
            m = (65 - length(string)) % 2
            string = copies(' ',m)||string||copies(' ',m)
            string = left(string,65,' ')
            line = '/*' string '*/'
            call out(line)
          end
        else
          line = '/*' string '*/'
        call out(string)
        string = wrd
      end
    else
      string = string wrd
  end

  m = (65 - length(string)) % 2
  string = copies(' ',m)||string||copies(' ',m)
  string = left(string,65,' ')
  line = '/*' string '*/'
  call out(line)

  call out(BoxStart)
  return

BoxOut:
  Parse arg data

  call out(BoxStart)

  string = ''
  do w = 1 to words(data)
    wrd = word(data,w)
    if length(string wrd) > 65 then
      do
        line = '/*' left(string,65,' ') '*/'
        call out(line)
        string = wrd
      end
    else
      do
       if length(string) = 0 then
         string = wrd
       else
         string = string wrd
      end
  end

  string = left(string,65,' ')
  line = '/*' string '*/'
  call out(line)

  call out(BoxStart)
  return

OatOut:
  Parse arg data,comment

  if substr(comment,1,2) <> 's-' then
    comment = '  '||comment

  comment = left(comment,27,' ')

  str = left(data,39,' ')||'/* '||comment||'*/'
  call out(str)
  return

out:
  parse arg string
  ol = OatTable.0
  ol = ol + 1
  OatTable.ol = string
  OatTable.0 = ol
  return
